mod errors;
mod governor;
mod key_extractor;
use crate::governor::Governor;
use ::governor::clock::{Clock, DefaultClock};
use ::governor::middleware::{NoOpMiddleware, StateInformationMiddleware};
use axum::response::Response ;
use http::request::Request;
use futures::future;
use futures::future::BoxFuture;
use futures::future::Either;
use http::header::{HeaderName, HeaderValue};
use http::{StatusCode, HeaderMap};
use key_extractor::KeyExtractor;
use pin_project::pin_project;
use std::task::{Context, Poll};
use std::{future::Future, pin::Pin};
use tower::{BoxError, Layer, Service};

// Implement Service for Governor
impl<K, S, T> Service<Request<T>> for Governor<K, NoOpMiddleware, S>
where
    K: KeyExtractor,
    S: Service<Request<T>>,
    S::Error: Into<BoxError>,
{
    type Response = S::Response;
    type Error = BoxError;
    type Future = RateLimitHeaderFut<S::Future>;

    fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
        // Our middleware doesn't care about backpressure so its ready as long
        // as the inner service is ready.
        self.inner.poll_ready(cx).map_err(Into::into)
    }

    fn call(&mut self, request: Request<T>) -> Self::Future {
        if let Some(configured_methods) = &self.methods {
            if !configured_methods.contains(request.method()) {
                // The request method is not configured, we're ignoring this one.
                let fut = self.inner.call(request);
                fut
            }
        }
    }
}
#[pin_project]
pub struct RateLimitHeaderFut<F>
where
    F: Future,
{
    #[pin]
    response_future: F,
    #[pin]
    burst_size: u32,
    #[pin]
    remaining_burst_capacity: u32,
}

impl<F, Error> Future for RateLimitHeaderFut<F>
where
    F: Future<Output = Result<Response, Error>>,
    Error: Into<BoxError>,
{
    type Output = Result<Response, Error>;

    fn poll(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output> {
        // Call the magical `project` method generated by `#[pin_project]`.
        let this = self.project();

        // `project` returns a `__ResponseFutureProjection` but we can ignore
        // the exact type. It has fields that matches `ResponseFuture` but
        // maintain pins for fields annotated with `#[pin]`.

        // `this.response_future` is now a `Pin<&mut F>`.
        let response_future: Pin<&mut F> = this.response_future;

        // And `this.burst_size` is a `Pin<&mut u32>`.
        let burst_size: Pin<&mut u32> = this.burst_size;

        // And `this.burst_size` is a `Pin<&mut u32>`.
        let remaining_burst_capacity: Pin<&mut u32> = this.remaining_burst_capacity;

        match response_future.poll(cx) {
            Poll::Pending => Poll::Pending,
            Poll::Ready(response) => {
                return Poll::Ready(match response {
                    Ok(mut response) => {
                        let headers = response.headers_mut();
                        headers.insert(
                            HeaderName::from_static("x-ratelimit-limit"),
                            self.burst_size.into(),
                        );
                        headers.insert(
                            HeaderName::from_static("x-ratelimit-remaining"),
                            self.remaining_burst_capacity.into(),
                        );
                        Ok(response)
                    }
                    Err(err) => Err(err),
                })
            }
        }
    }
}

// Implementation of Service for StateInformationMiddleware. You can have more than one!
impl<K, S, T> Service<Request<T>> for Governor<K, StateInformationMiddleware, S>
where
    K: KeyExtractor,
    S: Service<Request<T>>,
    S::Error: Into<BoxError>,
{
    type Response = S::Response;
    type Error = BoxError;
    type Future = WhitelistedHeaderFut<S::Future>;

    fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
        // Our middleware doesn't care about backpressure so its ready as long
        // as the inner service is ready.
        self.inner.poll_ready(cx).map_err(Into::into)
    }

    fn call(&mut self, req: Request<T>) -> Self::Future {
        if let Some(configured_methods) = &self.methods {
            if !configured_methods.contains(req.method()) {
                // The request method is not configured, we're ignoring this one.
                let fut = self.inner.call(req);
                return future::Either::Right(future::Either::Right(WhitelistedHeaderFut {
                    future: fut,
                }));
            }
            // Use the provided key extractor to extract the rate limiting key from the request.
            match self.key_extractor.extract(&req) {
                // Extraction worked, let's check if rate limiting is needed.
                Ok(key) => match self.limiter.check_key(&key) {
                    Ok(snapshot) => {
                        let fut = self.inner.call(req);
                        future::Either::Right(future::Either::Left(RateLimitHeaderFut {
                            future: fut,
                            burst_size: snapshot.quota().burst_size().get(),
                            remaining_burst_capacity: snapshot.remaining_burst_capacity(),
                        }))
                    }

                    Err(negative) => {
                        let wait_time = negative
                            .wait_time_from(DefaultClock::default().now())
                            .as_secs();

                        #[cfg(feature = "log")]
                        {
                            let key_name = match self.key_extractor.key_name(&key) {
                                Some(n) => format!(" [{}]", &n),
                                None => "".to_owned(),
                            };
                            log::info!(
                                "Rate limit exceeded for {}{}, quota reset in {}s",
                                self.key_extractor.name(),
                                key_name,
                                &wait_time
                            );
                        }

                        // let mut response_builder = AxumResponse::builder();
                        // response_builder
                        //     .status(StatusCode::TOO_MANY_REQUESTS)
                        //     .header("x-ratelimit-after", wait_time)
                        //     .header("x-ratelimit-limit", negative.quota().burst_size().get())
                        //     .header("x-ratelimit-remaining", 0);
                        // let response = self
                        //     .key_extractor
                        //     .exceed_rate_limit_response(&negative, response_builder);

                        let mut headers: HeaderMap


                        future::Either::Left(future::err(
                            error::InternalError::from_response("TooManyRequests", response).into(),
                        ))
                    }
                },

                // Extraction failed, stop right now.
                Err(e) => future::Either::Left(future::err(e.into())),
            }
        }
    }
}
#[pin_project]
pub struct WhitelistedHeaderFut<F>
where
    F: Future,
{
    #[pin]
    response_future: F,
}

impl<F,  Error> Future for WhitelistedHeaderFut<F>
where
    F: Future<Output = Result<Response, Error>>,
{
    type Output = F::Output;

    fn poll(mut self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output> {
        // Call the magical `project` method generated by `#[pin_project]`.
        let this = self.project();

        // `project` returns a `__ResponseFutureProjection` but we can ignore
        // the exact type. It has fields that matches `ResponseFuture` but
        // maintain pins for fields annotated with `#[pin]`.

        // `this.response_future` is now a `Pin<&mut F>`.
        let response_future: Pin<&mut F> = this.response_future;
        match response_future.poll(cx) {
            Poll::Pending => Poll::Pending,
            Poll::Ready(response) => Poll::Ready(match response {
                Ok(mut response) => {
                    let headers = response.headers_mut();
                    headers.insert(
                        HeaderName::from_static("x-ratelimit-whitelisted"),
                        HeaderValue::from_static("true"),
                    );
                    Ok(response)
                }
                Err(err) => Err(err),
            }),
        }
    }
}
